<!doctype html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>c3dl Ref Tests</title>
    <script type="text/javascript" src="./c3dl/c3dapi.js" ></script>
    <script type="text/javascript" src="tests.js"></script>
  </head>
  <body>
    <h1>c3dl Ref Test Runner</h1>
    <h3>Settings</h3>
    <div>Run Tests: 
      <select id="test-type" onchange="updateSelectedTests();">
        <option value="Static,Moving" selected>All</option>
        <option value="Static">Static</option>
        <option value="Moving">Moving</option>
        <option value="Calibration">Calibration</option>
      </select>&nbsp;
      Blur Radius: 
        <input type="text" size="2" id="sigma" onchange="updateTolerance();">&nbsp;
      Epsilon (0-1.0): 
        <input type="text" size="4" id="epsilon" onchange="updateTolerance();">&nbsp;
      <input onclick="runTests(selectedTests);" type="button" value="Start"></input>
      <span id="testCount"></span>
    </div>
    <h3>Results</h3>
    <div id="results" style="margin: 5px; padding-top: 10px;">
       <canvas id="test" width="100" height="100"></canvas>
    </div>
    <div id="total">
    </div>
    <script>
      var selectedTests = [];
      var total = document.getElementById('total');
      total.innerHTML = '';
      var duck;
      updateSelectedTests();

      // Tolerance values and kernel for blur
      var sigma = 2; // radius
      document.getElementById('sigma').value = sigma;
      var epsilon = 0.05; // match accuracy ~5%
      document.getElementById('epsilon').value = epsilon;
      var kernel, kernelSize, kernelSum;
      buildKernel();     
            
      function canvasMain(canvasName){
        // Create new c3dl.Scene object
        scn = new c3dl.Scene();
        scn.setCanvasTag(canvasName);
        // Create GL context
        renderer = new c3dl.WebGL();
        renderer.createRenderer(this);
        // Attach renderer to the scene
        scn.setRenderer(renderer);
        scn.init(canvasName);
        if(renderer.isReady() ){
          duck = new c3dl.Collada();
          duck.init("./resources/duck.dae");
          // Add the object to the scene
          scn.addObjectToScene(duck);
          // Create a camera
          var cam = new c3dl.FreeCamera();
          cam.setPosition(new Array(0, 0, -500.0));
          cam.setLookAtPoint(new Array(0.0, 0.0, 0.0));
          // Add the camera to the scene
          scn.setCamera(cam);
          scn.startScene();
        }
      }
      function updateSelectedTests() {
        var selectControl = document.getElementById('test-type');
        var selectedTags = selectControl.value.split(',');
        
        selectedTests = new Array();
        for(var i = 0; i < tests.length; ++i) {
          var found = false;
          // checking if any selected tags present in test tags
          for(var j = 0; j < selectedTags.length && !found; ++j) {
            for(var q = 0; q < tests[i].tags.length && !found; ++q) {
              if(tests[i].tags[q] == selectedTags[j]) found = true;
            }
          }
          if(found) {
            selectedTests.push(tests[i]);
          }
        }

        var testCount = document.getElementById('testCount');
        testCount.innerHTML = '&nbsp;(' + selectedTests.length + ' tests)';
      }

      function buildKernel() {
        var ss = sigma * sigma;
        var factor = 2 * Math.PI * ss;
        kernel = new Array();
        kernel.push(new Array());
        var i = 0, j;
        do {
            var g = Math.exp(-(i * i) / (2 * ss)) / factor;
            if (g < 1e-3) break;
            kernel[0].push(g);
            ++i;
        } while (i < 7);
        kernelSize = i;
        for (j = 1; j < kernelSize; ++j) {
            kernel.push(new Array());
            for (i = 0; i < kernelSize; ++i) {
                var g = Math.exp(-(i * i + j * j) / (2 * ss)) / factor;
                kernel[j].push(g);
            }
        }
        kernelSum = 0;
        for (j = 1 - kernelSize; j < kernelSize; ++j) {
            for (i = 1 - kernelSize; i < kernelSize; ++i) {
                kernelSum += kernel[Math.abs(j)][Math.abs(i)];
            }
        }
      }

      function updateTolerance() {
        var newS = document.getElementById('sigma').value;
        if (newS)
          sigma = parseInt(newS, 10);

        buildKernel();

        var newE = document.getElementById('epsilon').value;
        if (newE)
          epsilon = parseFloat(newE);
      }

      function getTest(testName) {
        testName || null;
        return testName;
      }

      function runTests(tests) {
        var results = document.getElementById('results');
        results.innerHTML = '<div id="status" style="margin-bottom: 10px;">Running... (this may take some time)</div>';
        var total = document.getElementById('total');
        total.innerHTML = '';

        var buildCanvas = function(id, w, h) {
          var c = document.createElement('canvas');
          c.id = id;
          c.width = w;
          c.height = h;
          c.className = "test";
          return c;
        };

        var link = function(name) {
          return '<a href="./resources/' + name + '">' + name + '</a>';
        };

        var titleText = function(testNumber, testTotal, time, testName, failMessage) {
          return "Test (" + testNumber + "/" + testTotal + ") [" + time + "ms]: " + link(testName) + 
                 (failMessage ? " -- FAILED (" + failMessage + ")" : " -- PASSED");
        };

        var getPixels = function(aCanvas, isWebGL) {        
          try {
            if (isWebGL) {
              var context = aCanvas.getContext("experimental-webgl");
              
              var data = null;
              try{
                // try deprecated way first (keeps code cleaner)
                data = context.readPixels(0, 0, aCanvas.width, aCanvas.height, context.RGBA, context.UNSIGNED_BYTE);
              }catch(e){
                // if that failed, try new way              
                if(!data){
                  data = new WebGLUnsignedByteArray(aCanvas.width * aCanvas.height * 4);
                  context.readPixels(0, 0, aCanvas.width, aCanvas.height, context.RGBA, context.UNSIGNED_BYTE, data);
                }
              }
              
              if(context.getError()){
                  data = new WebGLUnsignedByteArray(aCanvas.width * aCanvas.height * 4);
                  context.readPixels(0, 0, aCanvas.width, aCanvas.height, context.RGBA, context.UNSIGNED_BYTE, data);                
              }
              
              return data;
            } else {
              return aCanvas.getContext('2d').getImageData(0, 0, aCanvas.width, aCanvas.height).data;
            }
          } catch (e) {
            return null;
          }
        };

        var passedCount = 0, failedCount = 0, tl = tests.length;
        function nextTest(testNum) {
          if (testNum < tl) {
            window.setTimeout(function() { runOne(testNum); }, 10);
          } else {
            var info = "Tests Completed - " + failedCount + " failed, " + passedCount + " passed, " + (failedCount + passedCount) + " total."
            document.getElementById('status').innerHTML = info;
            total.innerHTML = info;
          }
        }

        var runOne = function(i) {
          var path = getTest(tests[i].path);
          var test = "t1_default";
          var result = document.createElement('div');
          result.id = test;
          var title = document.createElement('div');
          title.className = "title";
          result.appendChild(title);
          results.appendChild(result);
          var valueEpsilon = epsilon * 255;

          var original = buildCanvas(test + '-original', 100, 100);
          var current  = buildCanvas(test + '-current', 100, 100);
          var diff     = buildCanvas(test + '-diff', 100, 100);

          result.appendChild(original);
          result.appendChild(current);
          result.appendChild(diff);
          // draw the original based on stored pixels
          var origImg = new Image();
          origImg.src = path;
          var origCtx = original.getContext('2d');
          origCtx.drawImage(origImg,0,0,100,100);
          //toDo
          //var pixelsLen = test.pixels.length;

          // draw the current version from code, timing it
          var startTime = (new Date).getTime(), totalTime = 0;
            //ToDo: Adjust to store seperate tests in resources
          try{
            c3dl.addMainCallBack(canvasMain, test + "-current");
            c3dl.addModel("./resources/duck.dae");
            c3dl.init();
          }
          catch(e){
            alert("exception thrown zomg:" + e.toString());
          }
            // The program main
          var totalTime = (new Date).getTime() - startTime; 
          var currCtx = current.getContext('2d');
          var origImageData = origCtx.createImageData(100,100);
          var currImageData = currCtx.createImageData(100,100);
          
          //var currPix = getPixels(current, true);
          //var origPix = getPixels(original, true);
          alert (origImageData.data);
          alert (totalTime);
          alert (currImageData.data);
          // Blur pixels for diff
          //blur(getPixels(origCtx, true), 100, 100);
          //nextTest(i+1);
        };
        runOne(0);
        //window.setTimeout(function() { runOne(0); }, 10);
      }
      function blur(data, width, height) {
        var len = data.length;
        var newData = new Array(len);

        for (var y = 0; y < height; ++y) {
          for (var x = 0; x < width; ++x) {
            var r = 0, g = 0, b = 0, a = 0;
            for (j = 1 - kernelSize; j < kernelSize; ++j) {
              if (y + j < 0 || y + j >= height) continue;
              for (i = 1 - kernelSize; i < kernelSize; ++i) {
                if (x + i < 0 || x + i >= width) continue;
                r += data[4 * ((y + j) * width + (x + i)) + 0] * kernel[Math.abs(j)][Math.abs(i)];
                g += data[4 * ((y + j) * width + (x + i)) + 1] * kernel[Math.abs(j)][Math.abs(i)];
                b += data[4 * ((y + j) * width + (x + i)) + 2] * kernel[Math.abs(j)][Math.abs(i)];
                a += data[4 * ((y + j) * width + (x + i)) + 3] * kernel[Math.abs(j)][Math.abs(i)];
              }
            }
            newData[4 * (y * width + x) + 0] = r / kernelSum;
            newData[4 * (y * width + x) + 1] = g / kernelSum;
            newData[4 * (y * width + x) + 2] = b / kernelSum;
            newData[4 * (y * width + x) + 3] = a / kernelSum;               
          }
        }

        return newData;
      }
    </script>
  </body>
</html>